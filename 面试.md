### 项目介绍

我做的是一个Spring Boot + Vue实现的前后端分离的博客项目， 数据接口层整合了Mybatis Plus, 权限验证整合了shiro框架，因为是前后端分离的项目，所以选用了jwt作为用户身份凭证。考虑到项目可能需要部署多台服务器，会话等信息需要共享，选用主流的缓存中间件Redis做会话缓存

写的第一个项目是跟着网上的一个教程做的个人博客系统，第二个项目是在权限管理系统上增加了两个新功能，一是差旅单的申请，差旅单需要和已有的销售订单相关，销售订单有很多个后续差旅内容：包括安装、改造、维护等，申请差旅内容后需要提交部门经理审核，这一部分是对于出差内容的记录和维护；二是差旅报销，根据行程票、住宿发票等进行填写，计算出本次差旅报销金额，并提交部门经理、财务等审核后放款。

我认为在整个项目开展的过程中，系统设计是比较困难的，具体功能的实现主要是在于繁琐，而系统设计不当的话会更加增加这种繁琐的程度，系统设计体现在功能逻辑的设计、数据库表的设计、具体权限的设计等。

我认为在项目开展过程中遇到问题，首先要进行问题的划分和时间节点的制定，把问题细分后按照计划模块化地进行开发。我认为在初次接触开发项目的时候遇到的问题和以后进行开发将会面临的问题是有共同点的，因为在真实的开发场景中，也会不断地接触到以前没有接触到的新业务、新的技术栈等，要有一个开放的心态去正确地考量遇到的这些困难并且有条不紊地去解决。





#### 遇到的难点

1. Spring Boot虽然大幅度简化了J2EE的开发和配置，但是作为一个初学者来说，把诸如Mybatis, Shiro, jwt, Redis等插件与Spring Boot整合还是非常繁琐的，各个插件导入工程后需要做的写的配置文件以及需要重写的方法、需要实现的配置类和Java Bean比较繁杂，因为不想照着代码直接敲，所以最开始借鉴了项目的技术选型后自行在网络搜索如何整合这些插件，中文互联网上的信息鱼龙混杂，会严重影响开发效率，但后来更多地去阅读英文材料，发现无论是接入哪个插件，最靠谱也最全面的文档永远是官方文档，通过阅读官方文档和官方给出的示例，较为顺利地实现了以上插件的整合

2. 项目开发过程中更多的是繁琐较多，难点不算多，因为照着官方示例基本都做的下来，但是我觉得系统设计存在的一些难点：

   因为之前没有做过相关的开发工作，所以一开始虽然学了java基础，但是其实对于接口的理解非常有限，但是后来在做项目的过程中，发现接口设计是非常重要的，不管是前端接口还是后端接口，都需要清晰、容易理解。

   * 接口设计：在开发过程中，需要对接口进行设计。接口应该清晰、易于理解。在设计接口时，需要考虑接口的参数、返回值、状态码、异常处理等方面。

   还有一个比较难的地方在于跨域问题

   * 跨域问题：由于浏览器的同源策略，前端无法直接访问非同源的后端接口。在blog项目是在后端接口中添加CORS（跨域资源共享cross-origin-resource-sharing）头部信息，在oa项目使用代理服务器等技术来实现跨域请求(代理服务器和前端同源，与服务器非同源但不存在跨域问题，采用的是http请求不是ajax技术)。
   *  数据格式：前后端交互中需要考虑数据格式的问题。在前端，一般使用JSON格式来传输数据。在后端，Spring Boot 通过使用 Jackson 库将 Java 对象序列化成 JSON 格式，或者将 JSON 格式的数据反序列化成 Java 对象, 对应到项目中的话序列化的过程就是统一结果封装，后端返回的结果是封装好的JSON; 反序列化的话就比如在前端输入的一些信息在后端封装成一些实体类。
   *  请求和响应的处理：在前后端交互中，需要考虑请求和响应的处理。在前端，使用axios库来发起请求，并在请求完成后对响应进行处理。在后端，可以使用 Spring MVC框架来处理请求，返回数据给前端。
   * 安全问题：在前后端交互中，需要考虑安全问题，例如跨站脚本攻击（XSS）、跨站请求伪造（CSRF）等。在开发过程中，需要采用一些安全策略来确保系统的安全性。
   * 性能问题
     使用了Spring Boot提供的@Cacheable、@CachePut和@CacheEvict注解来实现缓存功能。@Cacheable注解表示缓存查询结果，@CachePut注解表示更新缓存数据，@CacheEvict注解表示删除缓存数据。通过使用缓存，我们可以减少数据库查询的次数，从而提高应用程序的性能。
     使用了Vue的异步组件来实现懒加载。通过使用异步组件，Vue会在需要使用该组件时再进行加载，从而减少初始加载时间和网络传输，提高应用程序的性能。

### 设计模式

#### 工厂模式

工厂模式是一种创建型模式，它提供了一种创建对象的最佳方式。工厂模式通过将对象的创建委托给一个专门的类来解决对象创建时的问题，这样可以使代码更加清晰和易于维护。

我们定义了一个接口Shape和三个实现类Rectangle、Square和Circle，这些类都实现了Shape接口。我们还定义了一个ShapeFactory工厂类，该类根据传入的参数创建不同的对象。通过使用工厂模式，我们可以在不知道对象具体实现的情况下创建对象，从而使代码更加清晰和易于维护。

#### 单例模式

单例模式也是一种创建型模式，保证一个类只有一个实例，并提供一个全局访问点。单例模式适用于在整个应用程序中共享对象的场景

```java
class Singleton{
	private static volatile Singleton singleton;
	private Singleton(){}
	public static Singleton getInstance() {
		if (singleton == null) {
			synchronized(Singleton.class) {
				if (singleton == null) {
					singleton = new Singleton();
				}
			}
		}
		return singleton;
	}
}
```

定义了一个Singleton类，该类只有一个私有构造函数和一个静态的getInstance()方法。getInstance()方法会在第一次调用时创建Singleton对象，并返回该对象的引用。在随后的调用中，该方法只返回已经创建的Singleton对象的引用。通过使用单例模式，我们可以保证在整个应用程序中只有一个Singleton对象的实例，并提供一个全局访问点。

#### 观察者模式

观察者模式是一种行为型模式，它定义了一种一对多的关系，使得多个观察者对象可以同时监听一个主题对象。当主题对象发生改变时，会通知所有观察者对象。

我们定义了一个Subject接口和一个ConcreteSubject类，该类维护了一个观察者列表和一个状态变量。我们还定义了一个Observer接口和两个具体的观察者类ConcreteObserver1和ConcreteObserver2。当ConcreteSubject对象的状态发生改变时，会通知所有观察者对象，并调用其update()方法来更新状态。

通过使用观察者模式，我们可以实现对象间的松耦合，当主题对象发生改变时，只需要通知观察者对象即可，而无需知道观察者对象的具体实现。这样可以提高代码的可重用性和可维护性。